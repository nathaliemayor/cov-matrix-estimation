"cov2Para",
"covCor",
"CCM",
"covDiag",
"covMarket",
"gis",
"qis",
"lis",
"CovMve",
"CovMcd",
"huge_glasso",
"equal_weights",
"factor1",
"factor3",
"RMT",
"sample"
)
roll <- seq(1, k - training_period, rolling_period)
cov_est_method <- "covMarket"
# ------------------------------------------------------------------------------
#                 HISTORICAL DATA - COMPUTE PORTFOLIOS
# ------------------------------------------------------------------------------
# cov_est_method <- "covMarket"
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = assets_returns,
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
test_rolling_cov_method
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
0.5/multiplicator
get_portfolio_metrics <- function (
stock_returns,
cov_est_method,
roll,
portfolio_optimization,
short = TRUE,
frequency = "monthly",
factor_returns = NULL
) {
if(frequency == "monthly"){
freq <- 12
multiplicator <- 1
}else if(frequency == "daily"){
freq <- 252
# 21 trading days in one month
multiplicator <- 21
}
training_data <- stock_returns[
(roll*multiplicator):(training_period*multiplicator+roll*multiplicator-1),
-1
]
training_date <- stock_returns[
(roll*multiplicator):(training_period*multiplicator+roll*multiplicator-1),
1
]
# rf <- window(TNX,
#            start = first(training_date),
#            end = last(training_date))$TNX.Adjusted %>%
# # get average monthly rate, percentage to decimal
# mean(na.rm = T)/freq
rf <- 0.42/multiplicator
if(cov_est_method %in% c("factor1", "factor3")){
training_factor_data <- factor_returns[
(roll*multiplicator):(training_period*multiplicator+roll*multiplicator-1),
-1
]
} else {
training_factor_data <- NULL
}
testing_data <- stock_returns[
((training_period+roll)*multiplicator):
(((training_period+roll+rolling_period)*multiplicator)-1),
]
date_test <- testing_data[,1]
rf_sr <- TNX$TNX.Adjusted %>%
# get average monthly rate, percentage to decimal
mean(na.rm = T)/freq
# covariance estimation
## linear shrinkage
rf_sr <- 0.5/multiplicator
if (!cov_est_method == "equal_weights") {
sigma_hat = get_covariance_estimate(
method = cov_est_method,
data = training_data,
factor_data = training_factor_data
)
}
# compute optimal portfolio weights
if (cov_est_method == "equal_weights") {
optimal_weights <- equal_weights(training_data)
} else {
inverse_sigma_hat = solve(sigma_hat)
if (portfolio_optimization == "tangent") {
# tangent portfolio from Markowitz formula
excess_er_hat <- colMeans(training_data - rf)
optimal_weights <- (inverse_sigma_hat %*% excess_er_hat)/
sum(inverse_sigma_hat %*% excess_er_hat)
if (short == FALSE) {
n_assets <- length(excess_er_hat)
# Set up the optimization problem
Dmat <- 2 * sigma_hat
dvec <- -excess_er_hat
Amat <- cbind(rep(1, n_assets), diag(n_assets))
bvec <- c(1, rep(0, n_assets))
# Additional constraint: no short selling
meq <- 1  # Constraint: weights sum to 1
# Solve the quadratic programming problem
optimal_weights <- solve.QP(Dmat, dvec, Amat, bvec, meq = meq)$
solution %>% as.matrix
rownames(optimal_weights) <- names(excess_er_hat)
}
} else if (portfolio_optimization == "minvar") {
# minvar portfolio from Markowitz formula
v_ones <- rep(1, dim(inverse_sigma_hat)[1])
optimal_weights <- as.numeric(inverse_sigma_hat %*% v_ones)/
as.numeric(v_ones %*% inverse_sigma_hat %*% v_ones)
}
}
period_returns <- rowSums(testing_data[,-1]*optimal_weights) %>%
tibble(date=date_test, returns = .) %>%
mutate(returns = returns)
ptf_variance <- t(as.matrix(optimal_weights)) %*%
as.matrix(cov(testing_data[,-1])) %*%
as.matrix(optimal_weights)
ptf_sd <- sqrt(ptf_variance)
SR <- ((mean(period_returns$returns)-rf_sr)/ptf_sd)
# results <- period_returns
results = list(period_returns, ptf_sd, SR, optimal_weights)
}
# ------------------------------------------------------------------------------
#                 HISTORICAL DATA - COMPUTE PORTFOLIOS
# ------------------------------------------------------------------------------
# cov_est_method <- "covMarket"
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = assets_returns[,1:26],
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
assets_returns[,1:26]
source("preamble.R")
# define paths
core_path <- "/Users/pro/Library/Mobile Documents/com~apple~CloudDocs"
data_path <- "masters_thesis/data"
from_date <- as.Date("1970-01-01")
to_date <- as.Date("2019-12-01")
# ------------------------------------------------------------------------------
#                 LOAD DATA
# ------------------------------------------------------------------------------
# load Fama-French data
data_files_names <- c(
"100_Portfolios_10x10_Wout_Div.CSV",
"100_Portfolios_10x10_Daily.CSV"
)
ff100_data <- lapply(
data_files_names,
get_data,
path = file.path(core_path,data_path)
)
names(ff100_data) <- c("monthly", "daily")
# ff100_data$daily <- ff100_data$daily %>% dplyr::mutate(across(-Date, ~ (. /100)))
# get 10-year Treasury notes and S&P500 data monthly and daily
tickers <- c("^TNX","^GSPC")
getSymbols(
tickers,
from = from_date,
to = to_date,
periodicity = "daily"
)
gspc_monthly <- GSPC$GSPC.Adjusted %>%
apply.monthly(mean) %>%
fortify.zoo %>%
mutate(returns = GSPC.Adjusted/lag(GSPC.Adjusted)-1)
# Load historical factor data (market, SMB, HML)
# downloaded directly from
# https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html
# Fama/French 3 Factors, CSV
factors <- rio::import(
file.path(core_path,data_path, "F-F_Research_Data_Factors.CSV")
) %>%
mutate(V1 = as.Date(
V1 %>% paste0("01"),
format = "%Y%m%d"
)
) %>%
dplyr::filter(V1 > from_date & V1 < to_date) %>%
dplyr::select(-RF) %>%
rename(date = V1)
factors_daily <- rio::import(
file.path(core_path,data_path, "F-F_Research_Data_Factors_daily.CSV")
) %>%
mutate(date = as.Date(date,
format = "%Y%m%d")) %>%
dplyr::filter(date > from_date & date < to_date) %>%
dplyr::select(-RF)
# dplyr::mutate(across(-date, ~ (. /100)))
# ------------------------------------------------------------------------------
#                 DEFINE PARAMETERS, SETTINGS
# ------------------------------------------------------------------------------
training_period <- 24 # months
rolling_period <- 6        # months
n <- dim(ff100_data$monthly)[2]
k <- dim(ff100_data$monthly)[1]
frequency <- "daily" # "monthly"
if(frequency == "daily"){
assets_returns <- ff100_data$daily
factors_returns <- factors_daily
}else if(frequency == "monthly"){
assets_returns <- ff100_data$monthly
factors_returns <- factors
}
# rules:
# lis: n_obs > n_var
# CovMve: n_obs > 2*n_var
cov_est_method = c(
"cov1Para",
"cov2Para",
"covCor",
"CCM",
"covDiag",
"covMarket",
"gis",
"qis",
"lis",
"CovMve",
"CovMcd",
"huge_glasso",
"equal_weights",
"factor1",
"factor3",
"RMT",
"sample"
)
roll <- seq(1, k - training_period, rolling_period)
# ------------------------------------------------------------------------------
#                 HISTORICAL DATA - COMPUTE PORTFOLIOS
# ------------------------------------------------------------------------------
cov_est_method <- "covMarket"
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = assets_returns[,1:26],
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
test_rolling_cov_method
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
# ------------------------------------------------------------------------------
#                 HISTORICAL DATA - COMPUTE PORTFOLIOS
# ------------------------------------------------------------------------------
cov_est_method <- "covMarket"
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = assets_returns[,1:50],
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = assets_returns[,1:97],
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = assets_returns,
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
test_rolling_cov_method <- pmap(
crossing(cov_est_method, roll),
get_portfolio_metrics,
stock_returns = ff100_data$daily,
portfolio_optimization = "tangent",
short = TRUE,
frequency = frequency,
factor_returns = factors_returns
)
method_order <- crossing(cov_est_method, roll) %>%
dplyr::select(cov_est_method) %>%
unique()
names(test_rolling_cov_method) <- rep(
method_order$cov_est_method,
each=length(roll)
)
results_by_cov <- lapply(
seq(1,(length(method_order$cov_est_method)-1)*length(roll)+1, length(roll)),
function(x)
test_rolling_cov_method[x:(x+length(roll)-1)]
)
names(results_by_cov) <- method_order$cov_est_method
returns <- lapply(method_order$cov_est_method, function(cov)
results_by_cov[[cov]] %>%
map_depth(1,1) %>%
reduce(rbind) %>%
filter(!is.na(returns))
)
# Calculate price-like index
prices <- lapply(returns, function(cov){
price_like_index <- cumprod(1 + (cov[,2]/100))
}) %>% reduce(cbind)
colnames(prices) <- method_order$cov_est_method
dates <- returns[[1]][,1]
prices$date <- dates$date
plot <- prices %>% pivot_longer(!date) %>%
# filter(name =="sample") %>%
ggplot(aes(x=date, y=value,color=name)) +
geom_line()
plotly::ggplotly(plot)
